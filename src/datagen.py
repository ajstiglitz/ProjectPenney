import numpy as np
import json

from src.helpers import PATH_DATA


HALF_DECK_SIZE = 26

def get_decks(n_decks: int,
              seed: int,
              half_deck_size: int = HALF_DECK_SIZE
             ) -> tuple[np.ndarray, np.ndarray]:
    """
    Efficiently generate `n_decks` shuffled decks using NumPy.
    
    Returns:
        decks (np.ndarray): 2D array of shape (n_decks, num_cards), 
        each row is a shuffled deck.

    """
    init_deck = [0]*half_deck_size + [1]*half_deck_size  # Base deck
    decks = np.tile(init_deck, (n_decks, 1))
    rng = np.random.default_rng(seed)
    rng.permuted(decks, axis=1, out=decks)
    return decks

#for making sure no files are overwritten, add a timestamp
#this is the function for that
def timestamp() -> str:
    from datetime import datetime as dt
    t = str(dt.now())
    r = t.replace(' ', '-').replace(':', '-').replace('.', '-')
    return r

# Write a function that stores data generated by get_decks()
#probably need a read and write to open and then edit file

# create an f string named after the seed and n_decks 
#new seed means new file
# and if the seed is already there and already has same n_decks then do nothing
# if different n_decks then save new file.

#store the seed and num_decks separately from the random decks
# ex: random decks could be stored as an array in a .npy file
#    use .save() and .load() functions in the library
#could then save the settings into a .json file
# name the file name of the .npy file as the key
# store the seed and num_decks as values



# Write a function that stores data generated by get_decks()
#probably need a read and write to open and then edit file
def store_decks(seed: int,
                n_decks: int, 
                decks: tuple[np.ndarray, np.ndarray]
               )-> dict:
    
    """
    Stores the data generated by get_decks() function into a dictionary.
        Data being stored is 2D array
    """

    return




# Make sure you can generate some decks,
#  and then generate some additional decks 
#       without losing track of seeds used
#

# Make sure you can duplicate your results, i.e. get the exact same decks twice
#

# Below is just notes for later
# After, you can write a function to score it


# you can input a seed when there is no data. Trigger to create the initial data
# otherwise you can have a file with a last state
# and get_state() or import from that file to get_state()