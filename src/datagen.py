import numpy as np
import json
import os
from datetime import datetime as dt

# 'data' is PATH_DATA, so need to add + '/' or something when in func
from src.helpers import PATH_DATA


HALF_DECK_SIZE = 26

def get_decks(n_decks: int,
              seed: int,
              half_deck_size: int = HALF_DECK_SIZE
             ) -> tuple[np.ndarray, np.ndarray]:
    """
    Efficiently generate `n_decks` shuffled decks using NumPy.
    
    Returns:
        decks (np.ndarray): 2D array of shape (n_decks, num_cards), 
        each row is a shuffled deck.

    """
    init_deck = [0]*half_deck_size + [1]*half_deck_size  # Base deck
    decks = np.tile(init_deck, (n_decks, 1))
    rng = np.random.default_rng(seed)
    rng.permuted(decks, axis=1, out=decks)
    return decks

#for making sure no files are overwritten, adds a timestamp
def timestamp() -> str:
    t = str(dt.now())
    r = t.replace(' ', '-').replace(':', '-').replace('.', '-')
    return r

#stores data generated by get_decks()
def store_decks(n_decks: int,
                seed: int, 
                result_decks: np.ndarray,
                path_data: str = PATH_DATA
               )-> dict:
    
    """
    Stores the data generated by get_decks() function into
        .npy file and .json file
    seed and num_decks stored separately from random decks
        random decks in .npy file using .save() and .load() function
    save the settings into a .json file...
    """
    # save self from overwriting with a timestamp
    ts = timestamp()

    npy_file = f"seed{seed}_decks{n_decks}_timestamp{ts}.npy"
    npy_path = os.path.join(path_data, npy_file)

    json_path = os.path.join(path_data, 'settings.json')
    
    # if it exists, then load the file
    # if no then create new one
    if os.path.exists(json_path):
        with open(json_path,'r') as f:
            settings = json.load(f)
    else:
        settings = {}
            
    if npy_file in settings:
        return settings


    # PATH_DATA is 'data' while npy_path = os.path.join(path_data, npy_file)

    #update to that it moves into the to_load folder for later scoring being saved
    
    #save the decks into the np file
    #random decks stored in the .npy file
    np.save(npy_path, result_decks)


    # timestamp in name, but not needed in what is actually saved
    # not not needed like seed or n_decks, was used as convention to
    # avoid file being over-written
    settings[npy_file] = {}
    settings[npy_file]['seed'] = seed
    settings[npy_file]['n'] = n_decks


    with open(json_path, 'w') as f:
        json.dump(settings, f)
    
    return settings


# need to store my data in a data folder, so its not just unsorted...
    # problems with pathing (PATH_DATA) for the folders...

# Make sure you can generate some decks,
#  and then generate some additional decks 
#       without losing track of seeds used
#

# Make sure you can duplicate your results, i.e. get the exact same decks twice
#

# Below is just notes for later
# After, you can write a function to score it


# you can input a seed when there is no data. Trigger to create the initial data
# otherwise you can have a file with a last state
# and get_state() or import from that file to get_state()